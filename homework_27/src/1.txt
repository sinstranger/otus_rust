use std::cell::RefCell;
use std::rc::Rc;

// Определяем тип для ссылки на узел
type Link<T> = Option<Rc<RefCell<Node<T>>>>;

// Структура узла списка
#[derive(Debug)]
struct Node<T> {
    value: T,
    next: Link<T>,
}

// Односвязный список
#[derive(Debug)]
struct List<T> {
    head: Link<T>,
}

impl<T> List<T> {
    // Создать новый пустой список
    fn new() -> Self {
        List { head: None }
    }

    // Добавить элемент в начало списка
    fn push_front(&mut self, value: T) {
        let new_node = Rc::new(RefCell::new(Node {
            value,
            next: self.head.take(),
        }));
        self.head = Some(new_node);
    }

    // Добавить элемент в конец списка
    fn push_back(&mut self, value: T) {
        let new_node = Rc::new(RefCell::new(Node {
            value,
            next: None,
        }));
        match &self.head {
            None => self.head = Some(new_node),
            Some(node) => {
                let mut current = Rc::clone(node);
                while let Some(ref next_node) = current.borrow().next {
                    current = Rc::clone(next_node);
                }
                current.borrow_mut().next = Some(new_node);
            }
        }
    }

    // Добавить элемент после N-го узла
    fn insert_after(&mut self, index: usize, value: T) {
        let mut current = match &self.head {
            None => return,
            Some(node) => Rc::clone(node),
        };

        for _ in 0..index {
            match current.borrow().next {
                Some(ref next_node) => current = Rc::clone(next_node),
                None => return, // Если список короче, чем N
            }
        }

        let new_node = Rc::new(RefCell::new(Node {
            value,
            next: current.borrow_mut().next.take(),
        }));
        current.borrow_mut().next = Some(new_node);
    }

    // Разделить список на два списка
    fn split_at(&mut self, index: usize) -> List<T> {
        let mut current = match &self.head {
            None => return List::new(),
            Some(node) => Rc::clone(node),
        };

        for _ in 0..index - 1 {
            match current.borrow().next {
                Some(ref next_node) => current = Rc::clone(next_node),
                None => return List::new(), // Если список короче, чем N
            }
        }

        let new_list = List {
            head: current.borrow_mut().next.take(),
        };

        new_list
    }

    // Получить итератор по всем элементам списка
    fn iter(&self) -> ListIter<T> {
        ListIter {
            current: self.head.clone(),
        }
    }

    // Изменить значение N-го элемента
    fn modify_at(&mut self, index: usize, new_value: T) {
        let mut current = match &self.head {
            None => return,
            Some(node) => Rc::clone(node),
        };

        for _ in 0..index {
            match current.borrow().next {
                Some(ref next_node) => current = Rc::clone(next_node),
                None => return, // Если список короче, чем N
            }
        }

        current.borrow_mut().value = new_value;
    }
}

// Итератор для списка
struct ListIter<T> {
    current: Link<T>,
}

impl<T> Iterator for ListIter<T> {
    type Item = T;

    fn next(&mut self) -> Option<Self::Item> {
        self.current.take().map(|node| {
            let node = node.borrow();
            self.current = node.next.clone();
            Rc::try_unwrap(Rc::clone(&node))
                .ok()
                .unwrap()
                .into_inner()
                .value
        })
    }
}

fn main() {
    let mut list = List::new();
    
    // Добавляем элементы
    list.push_front(1);
    list.push_front(2);
    list.push_back(3);
    
    // Добавление после второго элемента
    list.insert_after(1, 4);
    
    // Разделение списка
    let new_list = list.split_at(2);
    
    // Изменяем значение первого элемента
    list.modify_at(0, 10);
    
    // Печать всех элементов
    for val in list.iter() {
        println!("{}", val);
    }
}
